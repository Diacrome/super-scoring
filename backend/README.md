Подключиться к базе можно несколькими способами:\
**Способ 1**: В командной строке написать: docker exec -it *docker_container_name*(что-то типа super-scoring_postgres_1)
psql -U hh\
**Способ 2**: В командной строке написать: docker exec -it *docker_container_name*(что-то типа super-scoring_postgres_1)
\bin\bash и уже в там можно вызвать psql-U hh\
**Способ 3**: Если у вас есть postgres на компьютере то можно написать psql -U hh -p выбранный_вами_порт\
**Способ 4**: Через pgadmin: Выбрать создать сервер, выбрать любое имя и указать\
*host*: localhost\
*port*: 5444\
*Maintenance*: hh\
*user*: hh\
*pass*: hh\
Тестовая таблица будет лежать в Databases/hh/Schemas/public/Tests\
**Способ 5**: Можно через IDEA во вкладке databases, выбрав PostgreSQL и указав параметры такие же, как в пункте выше.
Не знаю доступно ли это в IDEA community edition.\
**Способ 6**: jdbc:postgresql://localhost:*5444*/postgres (вместо 5444 нужно указать свой порт) Это если хотите через
Connection.

## Api приложения


### Получение начальных сведений о тесте по id

`GET /test/info/{id}`

Возвращает JSON объект с полями:

* **id** - id теста
* **name** - название теста
* **description** - подробное описание теста, возможно в html формате

Пример возвращаемого объекта:

{
    "id": 1,
    "name": "Математический тест",
    "description": "Решите 10 математических задач.",
}

### Приветственное сообщение

`GET /hello`

Возвращает приветственное сообщение


### Создание записи о новом прохождении теста

`POST /start/{testId}`

В заголовке "Authorization" HTTP-запроса получает строку - токен.
Создает в таблице test_pass запись о процедуре прохождения пользователем теста с переданным id,
выбирая установленное согласно заданному для теста распределению по весам количество
произвольных вопросов относящихся к данному тесту.

**Возвращает**
- 201, если добавление прошло успешно.
- 401, если не получен токен,
- 404, если пользователь или тест не найден в базе,
- 400 если пользователь уже имеет начатый тест,
- 400 + объект с дополнительной информацией, если пользователь исчерпал количесво доступных попыток, 
или успешно прошел тест в течение промежутка времени указанного в свойствах теста. 
Время передается в формате timestamp в секундах.

Примеры возвращаемого объекта:

{
"startResult": "SPENT", 
"attempts": 3, 
"nextAttempt": 1658154396
} - истрачены три разрешенные попытки, следующая попытка 18 июля 2022 г., 14:26:36

{
"startResult": "PASSED", 
"attempts": null, 
"nextAttempt": 1658155204
} - тест успешно пройден, следующая попытка 18 июля 2022 г. 14:40:04

### Получение вопросов для прохождения теста 

`GET /questions`

В заголовке "Authorization" HTTP-запроса получает строку - токен.
Возвращает словарь: ключ - "question", значение - словарь, где:

ключ - порядковый номер вопроса в прохождении,
значение - объект с полями:
* **question** - текст вопроса
* **payload** - варианты ответа (в виде: {"1":"первый вариант ответа","2":"второй вариант ответа"}})

Пример возвращаемого объекта:

{"question": { "1": { "question": "5\*4 = ", "payload": { "1": 1, "2": 3, "3": 4, "4": 20 }, "answerType": "SINGLE_CHOICE"}, "2": { "question": "1\*1 = ", "payload": { "1": 1, "2": 3, "3": 4, "4": 1 }, "answerType": "SINGLE_CHOICE" } } }

Возвращает код 404 если для данного пользователя не запущено прохождение теста или пользователь не найден в базе.



### Авторизация по токену

`GET /auth/check-token`

В заголовке "Authorization" HTTP-запроса получает строку - токен.
Возвращает JSON объект с единственным полем:**name** - имя пользователя.

Пример возвращаемого объекта:

{"name": "Anna"}

Возвращает ошибку 404, если актуального токена нет в базе.

### Авторизация по логину и паролю

`POST /auth/token`

Получает логин и пароль пользователя в виде @FormParam в формате *x-www-form-urlencoded*.
Создает в таблице token новый токен для пользователя, существующего в базе.
Возвращает JSON объект с единственным полем: **token** - строка с токеном.

Пример возвращаемого объекта:

{"token": "ktuq13qll08kmg8oc49b"}

Возвращает ошибку 404, если пользователь не найден в базе.

`POST /auth/register`

Получает логин, пароль и имя в виде @FormParam в формате *x-www-form-urlencoded*.
Важно! Регистрация только обычных пользователей.

Возвращает 201, если пользователь успешно добавлен.
Возвращает 401, если в базе уже есть пользователь с таким логином.

### Наделение пользователя правами администратора
`POST /auth/set-admin`

**Получает**
- логин пользователя, которого надо сделать админом (`String login`) в виде @FormParam в формате *x-www-form-urlencoded*.
- токен из заголовка запроса (`String authorization`) в виде @HeaderParam

**Возвращает**
- 201 если операция произведена.
- 404, если токен не связан с пользователем / не валиден.
- 403, если текущий пользователь не является администратором.
- 400, если пользователя нет или запись не удалось произвести корректно.


### Пароль в базе данных хранится в виде хеша, сам пароль написан рядом в виде комментария

### Формат возвращаемого ответа для разных answer_type
`SINGLE_CHOICE` answer = '{"answer": "1"}' - по ключу answer в json можно получить ключ правильного ответа в payload<br> 
`MULTIPLE_CHOICE` answer ='{"multiple_answer1": "2", "multiple_answer2": "4"}' - ключи multiple_answer[1,2,3...] в json содержат ключ правильных ответов в payload <br>
`MULTIPLE_QUESTIONS_SINGLE_CHOICE` answer ='{"answer1": "2", "answer2" : "3"}'- ключи answer1, answer2 в json содержат ключ правильных ответов в payload для полей %answer1, %answer2 соотвественно.
`RANKING' answer = '{"1": "3", "2": "1", "3": "4", "4": "2"}' - ключи с номерами задают последовательность, какое содержимое из payload идёт первым, какой вторым и т.д.
 
`POST /answer`

Записывает ответ в базу данных.

**Получает**
- номер вопроса (`Integer questionOrder`) и ответ (`String answer`), в виде @FormParam в формате *x-www-form-urlencoded*.
- токен из заголовка запроса (`String authorization`) в виде @HeaderParam

**Возвращает**
- 201 и "Created", если запись произведена.
- 401 и "No token found", если токен не передан.
- 404, если токен не связан с пользователем / не валиден.
- 400 и "No testPass for the user!", если для пользователя, которому принадлежит токен, нет текущего прохождения.
- 400 и "Unable to save answer!", если запись не удалось произвести корректно.

### Создание теста 

`POST /test/create`

Создает новый тест.

**Получает**
- название теста (`String name`), описание (`String description`), время прохождения теста (`Intrger timeLimit`), 
допустимое количество попыток (`Intrger attemptQuantity`), 
интервал времени после которого можно будет повторно пройти тест (`Intrger repeatInterval`), 
и количество вопросов (`Integer questionCount`), в виде @FormParam в формате *x-www-form-urlencoded*.
- токен из заголовка запроса (`String authorization`) в виде @HeaderParam

**Возвращает**
- 201 и id созданного теста, если запись произведена.
- 404, если токен не связан с пользователем / не валиден.
- 403, если пользователь не является администратором.
- 400 и "Unable to save test!", если запись не удалось произвести корректно.

### Получение таблицы лидеров для теста по id

`GET /leaders/{testId}`

Поддерживает пагинацию (можно в параметрах указать page=N&perPage=M;
нумерация идёт с нуля, по умолчанию выдаётся нулевая страница с 10 объектами на странице)
Возвращает JSON объект с полями:

* **leaders** - таблица лидеров
* **page** - порядковый номер страницы (нумерация начинается с нуля)
* **perPage** - количество лрезультатов на странице
* **found** - общее количество найденных результатов

сама таблица лидеров -  JSON объект с числовыми полями,
соответствующими месту результата в рейтинге и содержащими JSON объект результата с полями:

* **name** - имя тестируемого
* **score** - набранное количество баллов

пример возращаемого объекта:
{"leaders":
        {
        "1":{"name":"Anna","score":10},
        "2":{"name":"Petr","score":6},
        "3":{"name":"Ivan","score":5}
        },
"page":0,
"perPage":3,
"found":3}

### Деактивация/активация теста

`POST /test/off/{id}`

`POST /test/on/{id}`
** Получает **
- Id теста (`Integer id`) в виде @PathParam
- токен из заголовка запроса (`String authorization`) в виде @HeaderParam

**Возвращает**
- 201, если изменения успешно произведены
- 404 и "Invalid token!" если токен не связан с пользователем / не валиден
- 403 и "Admin rights required", если пользователь не ADMIN
- 400 и "Unable to save test!", если запись не удалось произвести корректно.

### Установка вопроса по значению Id в состояние некативного ###

`PUT /question/inactive/{questionId}`

** Получает **
- Id вопроса в базе данных (Integer questionId) в виде @PathParam в формате целого числа
- токен из заголовка запроса (String authorization) в виде @HeaderParam

**Возвращает**
- 201 и "Set question not 'active' with this QuestionId", если изменения успешно произведены
- 401 и "No token found", если токен не передан.
- 404 и "Invalid token!" если токен не связан с пользователем / не валиден
- 403 и "Role user is not ADMIN. Access denied!", если пользователь имеет роль не ADMIN
- 400 и "Unable to set question is not activity!", если запись не удалось произвести корректно.
- 400 и "There is no question with such a QuestionId!" если отсутствует вопрос с заданным questionId

### Установка неактивного вопроса по значению Id в состояние ативного ###

`PUT /question/active/{questionId}`

** Получает **
- Id вопроса в базе данных (Integer questionId) в виде @PathParam в формате целого числа
- токен из заголовка запроса (String authorization) в виде @HeaderParam

**Возвращает**
- 201 и "Set question 'active' with this QuestionId", если изменения успешно произведены
- 401 и "No token found", если токен не передан.
- 404 и "Invalid token!" если токен не связан с пользователем / не валиден
- 403 и "Role user is not ADMIN. Access denied!", если пользователь имеет роль не ADMIN
- 400 и "Unable to set question is activity!", если запись не удалось произвести корректно.
- 400 и "There is no question with such a QuestionId!" если отсутствует вопрос с заданным questionId

### Статус прохождения теста

`GET /test/status`

В заголовке "authorization" HTTP-запроса получает строку - токен.
Возвращает JSON объект с полями:

* **authorized** : boolean
* **currentPass** : | null 
    * **answeredQuestions** : Словарь: [порядковый номер вопроса : отвечен или нет (boolean)]
    * **startTime** : время начала прохождения
    * **testId** : id базового теста

Пример возвращаемого объекта:
```json
{
  "authorized": true,
  "role": "ADMIN",
  "currentPass": {
    "answeredQuestions": {
      "1": true,
      "2": true,
      "3": true,
      "4": true,
      "5": true,
      "6": true,
      "7": true,
      "8": true,
      "9": false,
      "10": false
    },
    "startTime": "2022-05-28 09:48:23",
    "testId": 1
    "status": "PASS"
  }
}
```
Возвращает ошибку 401 "No token found", если не передан заголовок с токеном.

### Добавление вопроса к тесту

`POST question/add`

**Получает**
- токен из заголовка запроса (`String authorization`) в виде @HeaderParam
- поля вопроса в Body в виде JSON-объекта, пример:

`{
"testId": "1",
"wording": "3*5=",
"payload": "{\"1\": 81, \"2\": 3, \"3\": 4, \"4\": 15}",
"answer": "{\"answer\": \"4\"}",
"content": "null",
"answerType": "SINGLE_CHOICE",
"timeLimit": "30"
}`

**Возвращает**

- 201 и "Question added", если вопрос успешно добавлен.
- 404 и "There is no such test in the system", если вопрос добавляется в несуществующий тест.
- 403 и "Access denied", если пользователь не является админом.

### Генерация OpenAPI файла

1. Генерация на этапе package.
2. Сгенерированный файл лежит в ../docs/
3. При описании ручки можно добавить аннотации для наполнения документации по ней в виде:

`@Operation(summary = "Короткое описание", description = "Полное описание")
@ApiResponses(value = {@ApiResponse(
responseCode = "200", description = "Описание ответа",
content = {@Content(schema = @Schema(implementation = LeaderBoardDto.class))}
), @ApiResponse(responseCode = "401", description = "Описание другого ответа")})`

где:
- `@Operation` - описывает ручку в целом
- `@ApiResponse` - описывает ответ (автоматом они не подгружаются)
- `content` - описывает возвращаемые данные по схеме.

По аннотациям информацию можно, например, посмотреть тут: https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations#quick-annotation-overview

### Получение всех тестов

`GET /test/get-tests`

Доступно только для Role = ADMIN <br>
Поддерживает пагинацию (можно в параметрах указать page=N&perPage=M;
нумерация идёт с нуля, по умолчанию выдаётся нулевая страница с 10 объектами на странице)
Возвращает JSON объект с полями:

* **testMap** - map тестов, где key - номер теста в списке тестов отсортированных по возрастанию поля id, а value - тест со всеми полями из таблицы test
* **page** - порядковый номер страницы (нумерация начинается с нуля)
* **perPage** - количество результатов на странице
* **found** - общее количество найденных результатов
 
Поля в таблице test
* **id** - идентификатор
* **name** - наименование теста
* **description** - описание теста
* **date_created** - timestamp создния
* **date_modified** - timestamp последнего изменения
* **creator_id** - id пользователя, который создал этот тест
* **modifier_id** - id пользователя, который внёс последние изменеия
* **question_quantity** - общее количество вопросов в данном тесте
* **is_active** - true/false активен тест или нет


### Получение всех тестов

`GET /test/all-tests-for-user`

Доступно для всех типов пользователей <br>
Поддерживает пагинацию (можно в параметрах указать page=N&perPage=M;
нумерация идёт с нуля, по умолчанию выдаётся нулевая страница с 10 объектами на странице)
Возвращает JSON объект с полями:

* **testMap** - map тестов, где key - номер теста в списке тестов отсортированных по возрастанию поля id, а value - тест с полями из объекта класса TestDto
* **page** - порядковый номер страницы (нумерация начинается с нуля)
* **perPage** - количество результатов на странице
* **found** - общее количество найденных результатов
 
Поля в классе TestDto
* **id** - идентификатор
* **name** - наименование теста
* **description** - описание теста


### Получение всех вопросов по id теста

`GET /question/all-questions-in-test/{testId}`

Доступно только для Role = ADMIN <br>
В **testId** нужно указать идентификатор теста. <br>
Поддерживает пагинацию (можно в параметрах указать page=N&perPage=M;
нумерация идёт с нуля, по умолчанию выдаётся нулевая страница с 10 объектами на странице)
Возвращает JSON объект с полями:

* **questionMap** - map вопросов, где key - номер вопроса в списке вопросов отсортированных по возрастанию поля question.id, а value - вопрос со всеми полями из таблицы question
* **page** - порядковый номер страницы (нумерация начинается с нуля)
* **perPage** - количество результатов на странице
* **found** - общее количество найденных результатов

Поля в таблице question
* **id** - идентификатор
* **test_id** - id теста
* **question_wording** - формулировка вопроса
* **payload** - варианты ответов
* **answer** - правильный ответ
* **question_content** - контент, ссылка
* **answer_type** - тип ответа
* **date_created** - timestamp создния
* **date_modified** - timestamp последнего изменения
* **time_limit** - количество секунд предназначенное для вопроса
* **active** - true/false активен вопрос или нет


### Получение всех вопросов

`GET /question/all-questions`

Доступно только для Role = ADMIN <br>
Поддерживает пагинацию (можно в параметрах указать page=N&perPage=M;
нумерация идёт с нуля, по умолчанию выдаётся нулевая страница с 10 объектами на странице)
Возвращает JSON объект с полями:

* **questionMap** - map вопросов, где key - номер вопроса в списке вопросов отсортированных по возрастанию поля question.test_id, а value - вопрос со всеми полями из таблицы question
* **page** - порядковый номер страницы (нумерация начинается с нуля)
* **perPage** - количество результатов на странице
* **found** - общее количество найденных результатов

Поля в таблице question
* **id** - идентификатор
* **test_id** - id теста
* **question_wording** - формулировка вопроса
* **payload** - варианты ответов
* **answer** - правильный ответ
* **question_content** - контент, ссылка
* **answer_type** - тип ответа
* **date_created** - timestamp создния
* **date_modified** - timestamp последнего изменения
* **time_limit** - количество секунд предназначенное для вопроса
* **active** - true/false активен вопрос или нет

### Отмена прохожденя теста

`POST /cancel`

** Получает **
В заголовке "authorization" HTTP-запроса получает строку - токен.

**Возвращает**
- 201 и "Canceled!", если отмена прохождения теста прошла успешно
- 401 и "No token found", если токен не передан.
- 404 и "Invalid token!" если токен не связан с пользователем / не валиден
- 400 и "Unable to cancel testPass!", если запись об отмене теста не удалось произвести корректно.

### Получение результатов прохождения теста по pass_id без авторизации пользователя

`GET /test/results/{pass_id}`

Возвращает JSON объект с полями:

* **testPassId** - Id прохождения теста
* **status** - статус, в котором находится прохождение теста
* **finalScore** - результат, который набран после прохождения теста
* **maxPossible** - максимально возможный результат, который можно было набрать при прохождении теста
* **qualificationName** - название уровня квалификации, которому соответствует набранный результат после прохождения теста
* **endDateTime** - дата и время окончания прохождения теста
* **startDateTime** - дата и время начала прохождения теста
* **testId** - id теста, который был пройден
* **testName** - название теста


Пример возвращаемого объекта:
{
    "testPassId": 1,
    "status": "PASSED",
    "finalScore": 6,
    "maxPossible": null,
    "qualificationName": null,
    "endDateTime": "2022-06-22 11:58:20",
    "startDateTime": "2022-06-22 11:56:40",
    "testId": 1,
    "testName": "Математический тест"
}

### Отображение документации

1. Доступна на порту 8001
2. Для документации поднят отдельный контейнер с redocly/redoc
3. Спецификация и Dockerfile берутся из папки docs\
4. Спецификация автоматически генерируется и кладется в нужную папку при каждом локальном выполнении стадии package в maven


### Добавление теста

1. [Создать тест в базе](https://github.com/Diacrome/super-scoring/blob/main/backend/README.md#создание-теста)
2. [Добавить вопросы](https://github.com/Diacrome/super-scoring/blob/main/backend/README.md#добавление-вопроса-к-тесту)
3. [Задать распределение вопросов](https://github.com/Diacrome/super-scoring/blob/main/backend/README.md#добавление-распределения-вопросов-к-тесту)

